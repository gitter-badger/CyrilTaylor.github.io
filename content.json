[{"title":"UML建模详解","date":"2019-11-15T03:13:38.000Z","path":"posts/916534012/","text":"UML活动图 启动SD卡刷机程序读取分区表文件读取下一个节点的属性是否存在起始地址存在不存在将起始地址转为unit数保存起始地址计算分区起始地址将起始地址转为unit数保存起始地址存在上一个节点是否存在起始地址不存在无效起始地址是否有效有效对应的镜像文件是否存在存在不存在镜像文件哈希值匹配？匹配不匹配打印错误信息，并设置信号灯为常亮红色存在是否存在需下载的镜像文件不存在最后一个节点？否按照分区起始地址递增排序成功文件读取成功？失败存在分区表文件存在？不存在打印错误信息，并设置信号灯为常亮红色"},{"title":"PySide2 API","date":"2019-10-25T10:12:09.000Z","path":"posts/99546601/","text":"PySide2 Qt ModulesAPI"},{"title":"git命令详解","date":"2019-10-23T06:31:42.000Z","path":"posts/3542554366/","text":"git submodule git子模块允许在git工程子目录下包含一个或者多个git工程，并且可以用通过主目录的git进行管理，而各个子模块也可以保持本身git仓库的独立提交管理。"},{"title":"终极学习法--费曼技巧(The Feynman Technique)","date":"2019-10-22T06:52:50.000Z","path":"posts/2254807049/","text":"知识有两种类型，一种是注重了解事物的名称，可以认为是认知的过程；一类是注重了解事物本身，可以认为是理解的过程。"},{"title":"Linux内核驱动-GPIO","date":"2019-10-18T03:01:01.000Z","path":"posts/4193374346/","text":"/sys/kernel/debug/pinctrl echo 238 &gt; /sys/class/gpio/export; echo out &gt; /sys/class/gpio/gpio238/direction; echo 1 &gt; /sys/class/gpio/gpio238/value minicom输入命令 : local Echo on(Ctrl+A-&gt;Z-&gt;E) Port Config(Ctrl+A-&gt;Z-&gt;E) F - Hardware Flow Control: NO G - Software Flow Control : No"},{"title":"Linux内核驱动调试","date":"2019-10-14T11:00:02.000Z","path":"posts/1458029102/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899[ 391.911450] Unable to handle kernel NULL pointer dereference at virtual address 00000018[ 391.919552] pgd = e8ca0f1c[ 391.922256] [00000018] *pgd=6da5e003, *pmd=be8c2003[ 391.927137] Internal error: Oops: 207 [#1] SMP ARM[ 391.931921] Modules linked in: asix usbnet btrfs nls_ascii zstd_compress brcmfmac raid6_pq brcmutil libcrc32c cfg80211 lzo_compress zlib_deflate zstd_decompress xxhash g_mass_storage[ 391.948192] CPU: 1 PID: 2000 Comm: cat Not tainted 4.19.69-g37208387d-dirty #8[ 391.955403] Hardware name: Allwinner sun8i Family[ 391.960115] PC is at serial_sunxi_modem_status+0xc/0xdc[ 391.965336] LR is at serial_sunxi_get_mctrl+0xc/0x60[ 391.970294] pc : [&lt;c05f9078&gt;] lr : [&lt;c05f9154&gt;] psr: 600e0093[ 391.976551] sp : ee88dde8 ip : 00000015 fp : ede50058[ 391.981768] r10: 00000004 r9 : c1062d88 r8 : ee869c74[ 391.986987] r7 : 00000004 r6 : 000003e0 r5 : c10633f0 r4 : c10633f0[ 391.993503] r3 : 00000000 r2 : 00000002 r1 : 00000000 r0 : c10633f0[ 392.000023] Flags: nZCv IRQs off FIQs on Mode SVC_32 ISA ARM Segment none[ 392.007234] Control: 30c5387d Table: 684fa2c0 DAC: 344ff332[ 392.012973] Process cat (pid: 2000, stack limit = 0x4c81470b)[ 392.018712] Stack: (0xee88dde8 to 0xee88e000)[ 392.023067] dde0: c10633f0 c10633f0 000003e0 c05f9154 c10633f0 ee869be0[ 392.031235] de00: 000003e0 c05eea60 c0b77c10 00000040 00000000 00000000 00000000 00000000[ 392.039404] de20: c1008d14 00000000 c0b77c44 c0b77c10 c0b77c18 c1008d14 00000fb8 ffeee000[ 392.047572] de40: d2eb0f8f ee868800 dc7678f0 00000055 006000c0 000b6bf7 b6bf7000 d2eb0f8f[ 392.055740] de60: e84fa2d0 ede50058 00000001 007000c0 ee88df78 b6bf8000 00000000 00000000[ 392.063907] de80: ece8ccc0 c037f250 dc7678f0 ede50070 00020000 b6bf8000 ede50088 ece1d480[ 392.072076] dea0: 00000a06 ee983600 c037f054 00000000 ee88df78 b6bf8000 00000000 00020000[ 392.080244] dec0: 00020000 c03c38bc c1008d14 ece8ccc0 c03c384c c035a888 00000000 c1008d14[ 392.088413] dee0: 00000a06 b6bf7004 c100e734 ee88dfb0 00002710 b6f01000 b6ee5120 c02310b8[ 392.096582] df00: 00022000 00022000 b6bf7000 00000022 00000003 00000000 00000073 dc114200[ 392.104750] df20: 00000022 d2eb0f8f 000b6bf7 00020000 ece8ccc0 ffffe000 ee88df78 b6bf8000[ 392.112918] df40: 00000000 00020000 00020000 c035aa40 00022000 00000003 b6ee5120 ece8ccc0[ 392.121086] df60: c1008d14 ece8ccc0 b6bf8000 00000000 00000000 c035b000 00000000 00000000[ 392.129254] df80: ee88df7c d2eb0f8f 00020000 7fffe000 000165d0 00000003 c0201324 ee88c000[ 392.137423] dfa0: 00000003 c0201120 00020000 7fffe000 00000003 b6bf8000 00020000 000271c4[ 392.145592] dfc0: 00020000 7fffe000 000165d0 00000003 00000003 00000000 00000000 00020000[ 392.153759] dfe0: 00000000 bec97ab4 0001396d b6ea0f16 000e0030 00000003 00000000 00000000[ 392.161942] [&lt;c05f9078&gt;] (serial_sunxi_modem_status) from [&lt;c05f9154&gt;] (serial_sunxi_get_mctrl+0xc/0x60)[ 392.171417] [&lt;c05f9154&gt;] (serial_sunxi_get_mctrl) from [&lt;c05eea60&gt;] (uart_proc_show+0x1ac/0x40c)[ 392.180199] [&lt;c05eea60&gt;] (uart_proc_show) from [&lt;c037f250&gt;] (seq_read+0x1fc/0x478)[ 392.187768] [&lt;c037f250&gt;] (seq_read) from [&lt;c03c38bc&gt;] (proc_reg_read+0x70/0x88)[ 392.195078] [&lt;c03c38bc&gt;] (proc_reg_read) from [&lt;c035a888&gt;] (__vfs_read+0x2c/0x154)[ 392.202644] [&lt;c035a888&gt;] (__vfs_read) from [&lt;c035aa40&gt;] (vfs_read+0x90/0x154)[ 392.209776] [&lt;c035aa40&gt;] (vfs_read) from [&lt;c035b000&gt;] (ksys_read+0x60/0xc0)[ 392.216735] [&lt;c035b000&gt;] (ksys_read) from [&lt;c0201120&gt;] (ret_fast_syscall+0x0/0x4c)[ 392.224293] Exception stack(0xee88dfa8 to 0xee88dff0)[ 392.229341] dfa0: 00020000 7fffe000 00000003 b6bf8000 00020000 000271c4[ 392.237509] dfc0: 00020000 7fffe000 000165d0 00000003 00000003 00000000 00000000 00020000[ 392.245674] dfe0: 00000000 bec97ab4 0001396d b6ea0f16[ 392.250725] Code: c0a4cb30 e92d4070 e1a05000 e5903008 (e5d34018) [ 392.256813] ---[ end trace fa9691d56c9fdb90 ]---[ 392.261425] Kernel panic - not syncing: Fatal exception[ 392.266656] CPU2: stopping[ 392.269375] CPU: 2 PID: 0 Comm: swapper/2 Tainted: G D 4.19.69-g37208387d-dirty #8[ 392.278232] Hardware name: Allwinner sun8i Family[ 392.282946] [&lt;c022ca00&gt;] (unwind_backtrace) from [&lt;c0229128&gt;] (show_stack+0x10/0x14)[ 392.290689] [&lt;c0229128&gt;] (show_stack) from [&lt;c09e34e0&gt;] (dump_stack+0x84/0x98)[ 392.297907] [&lt;c09e34e0&gt;] (dump_stack) from [&lt;c022b8a8&gt;] (handle_IPI+0xf4/0x19c)[ 392.305213] [&lt;c022b8a8&gt;] (handle_IPI) from [&lt;c05811e4&gt;] (gic_handle_irq+0x74/0x78)[ 392.312778] [&lt;c05811e4&gt;] (gic_handle_irq) from [&lt;c0201b38&gt;] (__irq_svc+0x58/0x74)[ 392.320249] Exception stack(0xee89bf58 to 0xee89bfa0)[ 392.325294] bf40: 00000000 002ee53c[ 392.333462] bf60: eedcd670 c0236200 ee89a000 c1008d48 c1008d90 00000004 00000000 00000000[ 392.341631] bf80: c0e6aa70 ee89bfb0 c1008d48 ee89bfa8 c02264dc c02264e0 60010013 ffffffff[ 392.349802] [&lt;c0201b38&gt;] (__irq_svc) from [&lt;c02264e0&gt;] (arch_cpu_idle+0x34/0x38)[ 392.357195] [&lt;c02264e0&gt;] (arch_cpu_idle) from [&lt;c026893c&gt;] (do_idle+0x150/0x290)[ 392.364585] [&lt;c026893c&gt;] (do_idle) from [&lt;c0268d0c&gt;] (cpu_startup_entry+0x18/0x1c)[ 392.372148] [&lt;c0268d0c&gt;] (cpu_startup_entry) from [&lt;4020240c&gt;] (0x4020240c)[ 392.379100] CPU0: stopping[ 392.381810] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G D 4.19.69-g37208387d-dirty #8[ 392.390666] Hardware name: Allwinner sun8i Family[ 392.395372] [&lt;c022ca00&gt;] (unwind_backtrace) from [&lt;c0229128&gt;] (show_stack+0x10/0x14)[ 392.403111] [&lt;c0229128&gt;] (show_stack) from [&lt;c09e34e0&gt;] (dump_stack+0x84/0x98)[ 392.410327] [&lt;c09e34e0&gt;] (dump_stack) from [&lt;c022b8a8&gt;] (handle_IPI+0xf4/0x19c)[ 392.417631] [&lt;c022b8a8&gt;] (handle_IPI) from [&lt;c05811e4&gt;] (gic_handle_irq+0x74/0x78)[ 392.425194] [&lt;c05811e4&gt;] (gic_handle_irq) from [&lt;c0201b38&gt;] (__irq_svc+0x58/0x74)[ 392.432665] Exception stack(0xc1001f00 to 0xc1001f48)[ 392.437714] 1f00: 00000000 007016cc eedab670 c0236200 c1000000 c1008d48 c1008d90 00000001[ 392.445882] 1f20: 00000000 00000000 c0e6aa70 c1001f58 c1008d48 c1001f50 c02264dc c02264e0[ 392.454046] 1f40: 600e0013 ffffffff[ 392.457535] [&lt;c0201b38&gt;] (__irq_svc) from [&lt;c02264e0&gt;] (arch_cpu_idle+0x34/0x38)[ 392.464925] [&lt;c02264e0&gt;] (arch_cpu_idle) from [&lt;c026893c&gt;] (do_idle+0x150/0x290)[ 392.472315] [&lt;c026893c&gt;] (do_idle) from [&lt;c0268d0c&gt;] (cpu_startup_entry+0x18/0x1c)[ 392.479880] [&lt;c0268d0c&gt;] (cpu_startup_entry) from [&lt;c0e00d10&gt;] (start_kernel+0x41c/0x444)[ 392.488046] CPU3: stopping[ 392.490756] CPU: 3 PID: 0 Comm: swapper/3 Tainted: G D 4.19.69-g37208387d-dirty #8[ 392.499612] Hardware name: Allwinner sun8i Family[ 392.504318] [&lt;c022ca00&gt;] (unwind_backtrace) from [&lt;c0229128&gt;] (show_stack+0x10/0x14)[ 392.512057] [&lt;c0229128&gt;] (show_stack) from [&lt;c09e34e0&gt;] (dump_stack+0x84/0x98)[ 392.519273] [&lt;c09e34e0&gt;] (dump_stack) from [&lt;c022b8a8&gt;] (handle_IPI+0xf4/0x19c)[ 392.526576] [&lt;c022b8a8&gt;] (handle_IPI) from [&lt;c05811e4&gt;] (gic_handle_irq+0x74/0x78)[ 392.534140] [&lt;c05811e4&gt;] (gic_handle_irq) from [&lt;c0201b38&gt;] (__irq_svc+0x58/0x74)[ 392.541611] Exception stack(0xee89df58 to 0xee89dfa0)[ 392.546655] df40: 00000000 0011eb94[ 392.554824] df60: eedde670 c0236200 ee89c000 c1008d48 c1008d90 00000008 00000000 00000000[ 392.562992] df80: c0e6aa70 ee89dfb0 c1008d48 ee89dfa8 c02264dc c02264e0 600f0013 ffffffff[ 392.571162] [&lt;c0201b38&gt;] (__irq_svc) from [&lt;c02264e0&gt;] (arch_cpu_idle+0x34/0x38)[ 392.578552] [&lt;c02264e0&gt;] (arch_cpu_idle) from [&lt;c026893c&gt;] (do_idle+0x150/0x290)[ 392.585942] [&lt;c026893c&gt;] (do_idle) from [&lt;c0268d0c&gt;] (cpu_startup_entry+0x18/0x1c)[ 392.593504] [&lt;c0268d0c&gt;] (cpu_startup_entry) from [&lt;4020240c&gt;] (0x4020240c)[ 392.600462] Rebooting in 10 seconds.. 123456789prebuilts/gcc/linux-x86/arm/arm-eabi-6.3.1/bin/arm-eabi-nm out/linux-maxtropy_mxfitow_defconfig/vmlinux | grep -nir \"serial_sunxi_modem_status\"Binary file out/linux-maxtropy_mxfitow_defconfig/vmlinux matchesout/linux-maxtropy_mxfitow_defconfig/.tmp_System.map:18523:c05f906c t serial_sunxi_modem_statusout/linux-maxtropy_mxfitow_defconfig/System.map:18523:c05f906c t serial_sunxi_modem_statusprebuilts/gcc/linux-x86/arm/arm-eabi-6.3.1/bin/arm-eabi-addr2line -afispe out/linux-maxtropy_mxfitow_defconfig/vmlinux c05f90780xc05f9078: __raw_readb at io.h:108 (inlined by) serial_in at serial_sunxi.c:155 (inlined by) serial_sunxi_modem_status at serial_sunxi.c:333 12345678910111213141516Usage: prebuilts/gcc/linux-x86/arm/arm-eabi-6.3.1/bin/arm-eabi-addr2line [option(s)] [addr(s)] Convert addresses into line number/file name pairs. If no addresses are specified on the command line, they will be read from stdin The options are: @&lt;file&gt; Read options from &lt;file&gt; -a --addresses Show addresses -b --target=&lt;bfdname&gt; Set the binary file format -e --exe=&lt;executable&gt; Set the input file name (default is a.out) -i --inlines Unwind inlined functions -j --section=&lt;name&gt; Read section-relative offsets instead of addresses -p --pretty-print Make the output easier to read for humans -s --basenames Strip directory names -f --functions Show function names -C --demangle[=style] Demangle function names -h --help Display this information -v --version Display the program&apos;s version"},{"title":"Linux内核API参考手册","date":"2019-10-12T07:42:16.000Z","path":"posts/3397013201/","text":"GPIO GPIO"},{"title":"Java进阶","date":"2019-10-10T15:33:52.000Z","path":"posts/1503406261/","text":"接口和抽象类"},{"title":"C++进阶","date":"2019-10-10T13:37:02.000Z","path":"posts/1473815809/","text":"1. 程序虚拟存储器 1.1. 只读存储区 1.2. 堆/栈对比 1.3. 自由存储区 2. new和malloc的区别 3. 关键字static、const、volatile 3.1. static 3.1.1. 面向过程设计中的static 3.2. 面向对象设计中的static 3.3. const 3.3.1. const修饰成员变量 3.3.2. const修饰函数参数 3.3.3. const修饰成员函数 3.3.4. const修饰函数返回值 3.4. volatile 3.4.1. volatile的作用 3.4.2. volatile指针 3.5. 多线程下的volatile 4. C和C++相互调用 4.1. C++中调用C 4.2. C中调用C++ 5. 参考文献 1. 程序虚拟存储器 1.1. 只读存储区 只读存储区是在编译阶段就由编译器分配好的空间，其空间大小也在编译的时候已经固定，主要包括如下分区： 程序文本(.text) 该区域包含程序代码和文字常量。 常量指值不可改变的量，在C/C++中常量分为两种，文字常量（Literal Constant）和常变量（Constant Variable）。文字常量编译之后存储在代码段，不可寻址，常变量存储在数据区（堆、栈、BSS段或数据段），可寻址。 文字常量 文字常量又称为“字面常量”，包括数值常量、字符常量和符号常量。其特点是编译后写在代码区，不可寻址，不可更改，属于指令的一部分。 12int&amp; r=5; // 编译错误，文字常量不可寻址，因而无法为文字常量建立引用const int&amp; r=5; // 编译通过，在数据区开辟一个值为5的无名整型常变量，然后将引用r与这个整型常变量进行绑定。 数值常量 包括整型常量和实型常量。整型常量指常整数，有十进制、八进制、十六进制三种表示形式。实型常量包括单精度浮点数（float）、双精度浮点数（double）和长双精度浮点数（long double），表示形式有科学计数法和非科学计数法。 123int a=4; // 4为数值常量中的整型常量float b=4.4; // 4.4为数值常量中单精度实型常量double c=1.4e10; // 1.4e5表示的值为1.4×10^5，是数值常量中双精度实型常量 字符常量 指ASCII字符，有128个，分为普通字符和转义字符。普通字符指可直接书写的字符，如’a’和’b’。转义字符指不能直接书写的特殊字符，需要使用反斜杠进行表示，比如’\\t’表示水平制表符，’\\v’表示垂直制表符。 符号常量 用标识符代表一个常量，使用之前必须定义。例如宏定义和枚举元素。 12#define NUM 100 // NUM为符号常量，100为整型常量enum Weekday&#123;SUN, MON, TUES, WED, THU, FRI, SAT&#125;; // SUN,MON等均为符号常量 常变量 常变量指定义时必须显示初始化且值不可修改的变量。与其他变量一样被分配空间，是可以寻址的。注意，字符串常量是常变量的一种，名称为其本身，存储在代码段，可寻址，不可修改。 1cout&lt;&lt;&amp;”hello world”&lt;&lt;endl; //打印输出字符串常量”hello world”存储地址 常变量在C/C++中由const关键字来定义，分为全局常变量和局部常变量。二者的区别在于：全局常变量存储在代码段的只读内存区域，不可修改有操作系统来保障，局部常变量存储在栈区，在编程语言语义层面上由编辑器做语法检查来保障其值不可修改，因不是放在只读内存中，可以获得局部常变量的地址，运行时间接进行修改。参考如下代码： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;const int con1=3;void showValue(const int&amp; i)&#123; cout&lt;&lt;i&lt;&lt;endl;&#125;int main(int argc,char* argv[])&#123; const int con2=4; int* ptr=NULL; ptr=const_cast&lt;int*&gt;(&amp;con2); *ptr=5; showValue(con2); //1，输出5 cout&lt;&lt;\"con2:\"&lt;&lt;con2&lt;&lt;endl; //2，输出4 ptr= const_cast&lt;int*&gt;(&amp;con1); *ptr=6; //3，运行时错误，写入冲突&#125; 程序1处输出5，表明局部常量con2的值已经被修改，2处输出为结果仍然为4，并不是说明常变量con2的值没有被修改，而是因为编译器在代码优化的过程中已经将con2替换成了文字常量4。程序3处，运行时出错，表明全局常变量存储在只读内存，无法间接改写。 已初始化数据(.data) 包含已初始化的全局变量和静态变量，程序结束后由系统释放资源。 未初始化数据(.bss) 包含为初始化的全局变量和静态变量，并且以0填充变量数值，程序结束后由系统释放资源。 1.2. 堆/栈对比 特性 堆 栈 内存管理 通过函数malloc主动申请，需要程序主动释放，或者等待程序完全退出后由系统回收 用于存放函数的形参、局部变量等，生命周期结束后由操作系统自动分配释放 空间大小 可用空间即为虚拟内存的可用空间大小 可用空间远小于堆空间大小，如64位windows程序提供的是1MB，Linux是10MB 分配方式 均为通过malloc动态分配 分为静态分配和动态分配。静态分配由操作系统完成，如局部变量；动态分配通过alloca进行动态申请，生命周期结束后由系统自动释放，无需程序主动释放。 分配效率 堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。因而分配效率比较低 栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高 增长方向 向上增长，内存地址由低到高 向下增长，内存地址由高到低 存放内容 一般堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。 栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。 1.3. 自由存储区 自由存储区是C++上为new方法提供的一个抽象概念，具体对应的存储区域取决于编译器对于new方法的实现，自由存储区可能是映射到堆，也可能是映射到静态存储区，甚至可能不会重新分配内存，而仅仅只是将定位new所指定的地址返回，对于绝大部分的编译器来说，都是借助malloc来实现new操作符的功能，此时，自由存储区就是堆，而开发者可以通过重载操作符的方式重载new，此时就要依据开发者的实现来决定自由存储所对应的存储区域，例如如下的定位new表达式就是仅仅返回已定义的空间地址，而没有重新分配地址，具体可参考new和malloc的区别。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;char addr1[100];int main()&#123; char addr2[100]; char *addr3 = new char[100]; cout &lt;&lt; \"addr1 = \" &lt;&lt; (void*)addr1 &lt;&lt; endl; cout &lt;&lt; \"addr2 = \" &lt;&lt; (void*)addr2 &lt;&lt; endl; cout &lt;&lt; \"addr3 = \" &lt;&lt; (void*)addr3 &lt;&lt; endl; int *p = nullptr; // 返回静态区地址，并按地址右侧数据类型初始化该区域 p = new(addr1)int; *p = 1; cout &lt;&lt; (void*)p &lt;&lt; \" \" &lt;&lt; *p &lt;&lt; endl; // 返回栈区地址，并按地址右侧数据类型初始化该区域 p = new(addr2)int; *p = 2; cout &lt;&lt; (void*)p &lt;&lt; \" \" &lt;&lt; *p &lt;&lt; endl; //返回堆区地址，并按地址右侧数据类型初始化该区域 p = new(addr3)int; *p = 3; cout &lt;&lt; (void*)p &lt;&lt; \" \" &lt;&lt; *p &lt;&lt; endl; cin.get(); return 0;&#125; 2. new和malloc的区别 细说new与malloc的10点区别 3. 关键字static、const、volatile 3.1. static 3.1.1. 面向过程设计中的static 静态全局变量 静态全局变量如下特点： 静态全局变量数据存储在静态存储区，所以在编译时编译器将对其进行初始化，默认初始化为0，自动变量初始化为随机值 静态全局变量、静态局部变量与全局变量一样，在编译时编译器将对其进行唯一的一次初始化，程序开始运行时，静态存储区会拷贝到内存中 作用域为定义的位置到文件末尾，其他文件不可访问，用extern在其他文件引用时会运行时失败，全局变量可以在多个文件中引用 与全局变量一样，生命周期为进程的整个运行时，进程不退出，其占用的内存地址不会销毁，记录的值依旧有效 静态局部变量 静态全局变量数据存储在静态存储区，所以在编译时编译器将对其进行初始化，默认初始化为0，自动变量初始化为随机值 在编译时编译器将对其进行唯一的一次初始化，程序开始运行时，静态存储区会拷贝到内存中 只能被其同一作用域内的函数或者变量引用，作用域范围与局部变量相同 与全局变量一样，生命周期为进程的整个运行时，进程不退出，即使其作用域已执行完，其占用的内存地址不会销毁，记录的值依旧有效，下次读取到的依旧是上次修改后的值 静态函数 作用域为定义的位置到文件末尾，其他文件不可访问，而普通函数则可以被其他源文件引用 静态函数在内存中只拷贝一份，而普通函数在每次调用是都会拷贝一次 总结： 对象 存储区 作用域 生命周期 全局变量 .data字段(未初始化时编译器自动赋值) 全部源文件均可访问，其他源文件访问需要加extern关键字 进程运行开始到进程完全退出 静态全局变量 .data字段(未初始化时编译器自动赋值) 当前源文件定义处至文件末尾，其他源文件不可访问 进程运行开始到进程完全退出 静态局部变量 .data字段(未初始化时编译器自动赋值) 当前源文件定义处的作用域内 进程运行开始到进程完全退出 局部变量 栈内存/堆内存 当前源文件定义处的作用域内 当前源文件定义处的作用域内，作用域执行完则销毁 3.2. 面向对象设计中的static 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream.h&gt;class Myclass&#123;public: Myclass(int a,int b,int c); static void GetSum(); // 声明静态成员函数private: int a,b,c; static int Sum; // 声明静态数据成员&#125;;int Myclass::Sum=0; // 定义并初始化静态数据成员Myclass::Myclass(int a,int b,int c)&#123; this-&gt;a=a; this-&gt;b=b; this-&gt;c=c; Sum+=a+b+c; // 非静态成员函数可以访问静态数据成员&#125;void Myclass::GetSum() // 静态成员函数的实现&#123; // cout&lt;&lt;a&lt;&lt;endl; // 错误代码，a是非静态数据成员 cout&lt;&lt;\"Sum=\"&lt;&lt;Sum&lt;&lt;endl;&#125;void main()&#123; Myclass M(1,2,3); M.GetSum(); Myclass N(4,5,6); N.GetSum(); M.GetSum();&#125; 静态数据成员 静态数据成员数据存储在静态存储区，静态数据成员定义时要分配空间，所以类的声明中只能进行静态数据成员的声明，其定义和初始化必须在类声明外执行 静态数据成员只分配一次内存空间，因此该类的所以实例或子类实例，对该静态数据成员的引用均指向同一地址，一处修改，对于全部引用生效 静态数据成员不用对类进行实例化也可访问,但是跟普通数据成员一样，遵从public,protected,private访问规则 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为： ＜数据类型＞ ＜类名＞::＜静态数据成员名＞ = ＜值＞ 类的静态数据成员有两种访问形式：普通数据成员访问方式(＜类实例名＞.＜静态数据成员名＞)或静态数据成员特有访问方式(＜类类型名＞::＜静态数据成员名＞) 静态成员函数 类声明外的函数不能指定关键字static 类的静态成员函数有两种访问形式：普通成员函数访问方式(＜类实例名＞.＜静态成员函数名＞(＜参数表＞))或静态成员函数特有访问方式(＜类类型名＞::＜静态成员函数名＞(＜参数表＞)) 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数，非静态成员函数可以任意地访问静态成员函数和静态数据成员，但静态成员函数不能访问非静态成员函数和非静态数据成员 静态成员函数在内存中只拷贝一份，而普通函数在每次调用是都会拷贝一次 3.3. const const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。 3.3.1. const修饰成员变量 1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; int a1=3; //non-const data const int a2=a1; //const data int * a3 = &amp;a1; //non-const data,non-const pointer const int * a4 = &amp;a1; //const data,non-const pointer int * const a5 = &amp;a1; //non-const data,const pointer int const * const a6 = &amp;a1; //const data,const pointer const int * const a7 = &amp;a1; //const data,const pointer return 0;&#125; const修饰指针变量时： 只有一个const，如果const位于*左侧，表示指针所指数据是常量，不能通过解引用修改该数据；指针本身是变量，可以指向其他的内存单元。 只有一个const，如果const位于*右侧，表示指针本身是常量，不能指向其他内存地址；指针所指的数据可以通过解引用修改。 两个const，*左右各一个，表示指针和指针所指数据都不能修改。 3.3.2. const修饰函数参数 传递过来的参数在函数内不可以改变，与上面修饰变量时的性质一样。 123void testModifyConst(const int _x) &#123; _x=5; //编译出错&#125; 3.3.3. const修饰成员函数 const修饰的成员函数不能修改任何的成员变量(mutable修饰的变量除外) const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class Point&#123; public : Point(int _x):x(_x)&#123;&#125; void testConstFunction(int _x) const&#123; //错误，在const成员函数中，不能修改任何类成员变量 x=_x; //错误，const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量 modify_x(_x); &#125; void modify_x(int _x)&#123; x=_x; &#125; int x;&#125;; 3.3.4. const修饰函数返回值 指针传递 如果返回const data,non-const pointer，返回值也必须赋给const data,non-const pointer。因为指针指向的数据是常量不能修改。 1234567891011const int * mallocA()&#123; //const data,non-const pointer int *a=new int(2); return a;&#125;int main()&#123; const int *a = mallocA(); //int *b = mallocA(); ///编译错误 return 0;&#125; 值传递 如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。所以，对于值传递来说，加const没有太多意义。 所以： 不要把函数int GetInt(void) 写成const int GetInt(void) 不要把函数A GetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型 在编程中要尽可能多的使用const，这样可以获得编译器的帮助，以便写出健壮性的代码。 3.4. volatile 3.4.1. volatile的作用 volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。 123456789101112131415#include &lt;stdio.h&gt;void main()&#123; int i = 10; int a = i; printf(\"i = %d\", a); // 下面汇编语句的作用就是改变内存中 i 的值 // 但是又不让编译器知道 __asm &#123; mov dword ptr [ebp-4], 20h &#125; int b = i; printf(\"i = %d\", b);&#125; 然后，在 Debug 版本模式运行程序，输出结果如下： i = 10 i = 32 在 Release 版本模式运行程序，输出结果如下： i = 10 i = 10 输出的结果明显表明，Release 模式下，编译器对代码进行了优化，第二次没有输出正确的 i 值。把 i 的声明加上 volatile 关键字，在 Debug 和 Release 版本运行程序，输出为： i = 10 i = 10 其实不只是“内嵌汇编操纵栈”这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile用在如下的几个地方： 中断服务程序中修改的供其它程序检测的变量需要加volatile 多任务环境下各任务间共享的标志应该加volatile 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义 3.4.2. volatile指针 和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念： 修饰由指针指向的对象、数据是 const 或 volatile 的： 12const char* cpch;volatile char* vpch; 指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的： 12char* const pchc;char* volatile pchv; 注意： 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象 除了基本类型外，对用户定义类型也可以用volatile类型进行修饰 C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员 3.5. 多线程下的volatile 有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，如下： volatile BOOL bStop = FALSE; (1) 在一个线程中： 123while( !bStop ) &#123; ... &#125;bStop = FALSE;return; (2) 在另外一个线程中，要终止上面的线程循环： 12bStop = TRUE;while( bStop ); //等待上面的线程终止，如果bStop不使用volatile申明，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。 4. C和C++相互调用 4.1. C++中调用C 4.2. C中调用C++ 5. 参考文献 [1] C/C++文字常量与常变量"},{"title":"Linux设备树","date":"2019-10-09T07:01:43.000Z","path":"posts/3787073306/","text":"1. 设备树基础 1.1. 设备树的引入 1.2. 设备树特点 1.3. 编译设备树 2. 设备树dts/dtsi格式 3. 设备树dtb格式和结构 4. 内核head.S对uboot传参的处理 5. 设备树对平台信息的处理machine_desc 6. 设备树对运行时配置信息的处理 7. dtb到设备节点的转换 8. 设备节点到平台设备的转换 9. platform_device和platform_driver如何让匹配 10. 在根文件系统中查看设备树 11. 内核中设备树的操作函数 12. uboot如何给内核传dtb文件 13. 有了设备树后新内核对于设备处理的不同之处 14. aliases节点分析 15. 引入设备树对中断的影响 16. 番外篇-中断子系统之IRQ Domain介绍 17. 番外篇-中断子系统之IRQ number和中断描述符 18. 番外篇-中断子系统之内核对中断控制器的解析 19. 番外篇-中断子系统之初始化一个中断控制器 20. 番外篇-中断子系统之中断号的映射与反映射[一] 21. 番外篇-中断子系统之中断号的映射与反映射[二] 22. 番外篇-中断子系统之简单举例使用 23. 番外篇-中断子系统之驱动申请API 24. 番外篇-中断子系统之softirq 25. 番外篇-中断子系统之tasklet 26. 番外篇-中断子系统之workqueue[1] 27. 番外篇-中断子系统之CMWQ概述[2] 28. 番外篇-中断子系统之workqueue创建[3] 29. 番外篇-中断子系统之workqueue处理work[4] 30. 番外篇-中断子系统之workqueue使用 1. 设备树基础 1.1. 设备树的引入 Linus Torvalds在2011年3月17日的ARM Linux邮件列表宣称“this whole ARM thing is a fucking pain in the ass”，ARM Linux社区对此作出了回应，引入设备树。 ARM Device Tree起源于OpenFirmware (OF)，在过去的Linux中，arch/arm/plat-xxx和arch/arm/mach-xxx中充斥着大量的垃圾代码，相当多数的代码只是在描述板级细节，而这些板级细节对于内核来讲，不过是垃圾，如板上的platform设备、resource、i2c_board_info、spi_board_info以及各种硬件的platform_data。为了改变这种局面，Linux社区的大牛们参考了PowerPC等体系架构中使用的Flattened Device Tree（FDT），也采用了Device Tree结构，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。 Device Tree是一种描述硬件的数据结构，它起源于 OpenFirmware (OF)。在Linux 2.6中，ARM架构的板极硬件细节过多地被硬编码在arch/arm/plat-xxx和arch/arm/mach-xxx，采用Device Tree后，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。 Device Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性，其实就是成对出现的name和value。在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）： CPU的数量和类别 内存基地址和大小 总线和桥 外设连接 中断控制器和中断使用情况 GPIO控制器和GPIO使用情况 Clock控制器和Clock使用情况 这种以树状节点的方式描述一个设备的各种硬件信息：CPU、GPIO、时钟、中断、内存等，形成类似文本文件，很好的解决了这些问题。 它基本上就是画一棵电路板上CPU、总线、设备组成的树，Bootloader会将这棵树传递给内核，然后内核可以识别这棵树，并根据它展开出Linux内核中的platform_device、i2c_client、spi_device等设备，而这些设备用到的内存、IRQ等资源，也被传递给了内核，内核会将这些资源绑定给展开的相应的设备。 通常由.dts文件以文本方式对系统设备树进行描述，经过Device Tree Compiler(dtc)将dts文件转换成二进制文件binary device tree blob(dtb)，.dtb文件可由Linux内核解析，有了device tree就可以在不改动Linux内核的情况下，对不同的平台实现无差异的支持，只需更换相应的dts文件，即可满足。 1.2. 设备树特点 对于传统字符驱动的编写有两种方式： 一是在驱动程序中，直接写死硬件资源，如：GPIO、寄存器地址、中断号等，使得硬件改动时，必须修改驱动程序。 二是采用总线驱动platform模型，将硬件资源与驱动软件分离，在platform_device中描述硬件资源，arch/arm/mach-xxx对应的文件，便是以platform_device描述各自CPU对应的硬件资源；在platform_driver中分配/设置/注册 file_operations结构体, 并从platform_device获得硬件资源。这种编写方式使得驱动易于扩展，硬件改动时只需修改platform_device或者platform_driver，这就导致linux内核产生大量的冗余代码。 使用设备树的特点在于，在设备树dts文件指定硬件资源，dts被编译为dtb文件, 在启动单板时，U-boot会将dtb文件传给内核，使得驱动程序与硬件分离，我们只需要修改dts文件，便能实现需求。这就是设备树易于扩展，硬件有变动时不需要重新编译内核或驱动程序，只需要提供不一样的dtb文件。 1.3. 编译设备树 设备树文件的格式为dts，包含的头文件格式为dtsi，dts文件是一种人可以看懂的编码格式。但是uboot和linux不能直接识别，他们只能识别二进制文件，所以需要把dts文件编译成dtb文件。dtb文件是一种可以被kernel和uboot识别的二进制文件。把dts编译成dtb文件的工具是dtc。Linux源码目录下scripts/dtc目录包含dtc工具的源码。在Linux的scripts/dtc目录下除了提供dtc工具外，也可以自己安装dtc工具，linux下执行：sudo apt-get install device-tree-compiler安装dtc工具。其中还提供了一个fdtdump的工具，可以反编译dtb文件。dts和dtb文件的转换如图所示。 dtc工具的使用方法是：dtc –I dts –O dtb –o xxx.dtb xxx.dts，即可生成dts文件对应的dtb文件了。 在编译linux内核时。也可以直接make dtbs生成dtb文件。 2. 设备树dts/dtsi格式 3. 设备树dtb格式和结构 4. 内核head.S对uboot传参的处理 5. 设备树对平台信息的处理machine_desc 6. 设备树对运行时配置信息的处理 7. dtb到设备节点的转换 8. 设备节点到平台设备的转换 9. platform_device和platform_driver如何让匹配 10. 在根文件系统中查看设备树 11. 内核中设备树的操作函数 内核中开放出来的接口函数的声明大多在include/linux/下面，关于设备树的都是以ofxxx.h形式命名 12345678910111213141516171819202122232425262728/*--- 处理dtb文件 ---*/include/linux/of_fdt.h // dtb文件的相关操作函数, 我们一般用不到, 因为dtb文件在内核中已经被转换为device_node树(它更易于使用)/*--- 处理device_node ---*/include/linux/of_address.h // 地址相关的函数, 如 // of_get_address(获得reg属性中的addr, size值)include/linux/of_clk.hinclude/linux/of_dma.h // 设备树中DMA相关属性的函数include/linux/of_gpio.h // GPIO相关的函数include/linux/of_graph.h // GPU相关驱动中用到的函数, 从设备树中获得GPU信息include/linux/of.h // 提供设备树的一般处理函数, 如 // of_property_read_u32(读取某个属性的u32值) // of_get_child_count(获取某个device_node的子节点数)include/linux/of_iommu.hinclude/linux/of_irq.h // 中断相关的函数include/linux/of_mdio.h // MDIO (Ethernet PHY) APIinclude/linux/of_net.h // OF helpers for network devices.include/linux/of_pci.h // PCI相关函数include/linux/of_pdt.hinclude/linux/of_reserved_mem.h // reserved_mem的相关函数/*--- 处理 platform_device ---*/include/linux/of_device.h // 设备相关的函数，如 // of_match_device(从matches数组中取出与当前设备最匹配的一项)include/linux/of_platform.h // 把device_node转换为platform_device时用到的函数，如 // of_device_alloc(根据device_node分配设置platform_device) // of_find_device_by_node(根据device_node查找到platform_device) // of_platform_bus_probe(处理device_node及它的子节点) 以of_fdt.h 头文件中举几个例子 1234567891011121314151617181920//blob也就是启动时保留的那块存放dtb文件内存的起始地址,下面分别是从dtb文件中扫描获取信息/* For scanning an arbitrary device-tree at any time */extern char *of_fdt_get_string(const void *blob, u32 offset); // 从起始地址+偏移获取字符串extern void *of_fdt_get_property(const void *blob, // 通过起始地址 unsigned long node, const char *name, int *size);extern bool of_fdt_is_big_endian(const void *blob, // 判断某个节点是不是大端存放的 unsigned long node);extern int of_fdt_match(const void *blob, unsigned long node, // 判断节点是不是匹配的 const char *const *compat);extern void *of_fdt_unflatten_tree(const unsigned long *blob, // 解析dtb到device_node的函数 struct device_node *dad, struct device_node **mynodes);/* TBD: Temporary export of fdt globals - remove when code fully merged */extern int __initdata dt_root_addr_cells; // 内核dtb文件的根节点中addr-cells的值extern int __initdata dt_root_size_cells; // 内核dtb文件的根节点中size-cells的值extern void *initial_boot_params; // 内核存放dtb文件的地址(虚拟地址) 当然我们更多的是通过of.h文件中获取一个节点或者节点的信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 下面是在from节点下面,通过name,type或者compatible属性获取具有相同名字或类型的节点extern struct device_node *of_find_node_by_name(struct device_node *from, const char *name);extern struct device_node *of_find_node_by_type(struct device_node *from, const char *type);extern struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compat);// 当然这里也可以通过一个设备节点,获取里面某个属性的值static inline int of_property_read_u8(const struct device_node *np, const char *propname, u8 *out_value)&#123; return of_property_read_u8_array(np, propname, out_value, 1);&#125;static inline int of_property_read_u16(const struct device_node *np, const char *propname, u16 *out_value)&#123; return of_property_read_u16_array(np, propname, out_value, 1);&#125;static inline int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value)&#123; return of_property_read_u32_array(np, propname, out_value, 1);&#125;static inline int of_property_read_s32(const struct device_node *np, const char *propname, s32 *out_value)&#123; return of_property_read_u32(np, propname, (u32*) out_value);&#125;// 获取某个节点字符串数量static inline int of_property_count_strings(const struct device_node *np, const char *propname)&#123; return of_property_read_string_helper(np, propname, NULL, 0, 0);&#125;// 获取某个界定里的字符串数字static inline int of_property_read_string_array(const struct device_node *np, const char *propname, const char **out_strs, size_t sz)&#123; return of_property_read_string_helper(np, propname, out_strs, sz, 0);&#125;// 同时也可以获取到字符串数组的某个指定的字符串static inline int of_property_read_string_index(const struct device_node *np, const char *propname, int index, const char **output)&#123; int rc = of_property_read_string_helper(np, propname, output, 1, index); return rc &lt; 0 ? rc : 0;&#125; 基本上我们想到的获取设备树中那种信息，都会有相应的函数接口。我们只需要调用就可以了。 12. uboot如何给内核传dtb文件 13. 有了设备树后新内核对于设备处理的不同之处 14. aliases节点分析 15. 引入设备树对中断的影响 16. 番外篇-中断子系统之IRQ Domain介绍 17. 番外篇-中断子系统之IRQ number和中断描述符 18. 番外篇-中断子系统之内核对中断控制器的解析 19. 番外篇-中断子系统之初始化一个中断控制器 20. 番外篇-中断子系统之中断号的映射与反映射[一] 21. 番外篇-中断子系统之中断号的映射与反映射[二] 22. 番外篇-中断子系统之简单举例使用 23. 番外篇-中断子系统之驱动申请API 24. 番外篇-中断子系统之softirq 25. 番外篇-中断子系统之tasklet 26. 番外篇-中断子系统之workqueue[1] 27. 番外篇-中断子系统之CMWQ概述[2] 28. 番外篇-中断子系统之workqueue创建[3] 29. 番外篇-中断子系统之workqueue处理work[4] 30. 番外篇-中断子系统之workqueue使用"},{"title":"C++编程规范","date":"2019-10-08T09:51:15.000Z","path":"posts/3424946910/","text":"1. 常用单词缩写 1. 常用单词缩写 单词 缩写 解释 addition add 加 answer ans 响应、回答 array arr 数组、集合 average avg 平均 buffer buf / buff 缓冲区 capture cap / capt 捕获 check chk 检查 column col 列 control ctrl 控制 count cnt 计数器 decode dec 解码、译码 define def 定义 delete del 删除 destination dst / dest 目的 display disp 显示 division div 除法 encode enc 编码 environment env 环境 error err 错误 float flt 浮动、浮点 frequency freq 频率 header hdr 开始、开头 image img 影像、镜像 increment inc 增加、增量 index idx 索引、指示、 initalize init 初始化 iteration itr 循环、迭代 length len 长度 make mk 制造、形成 memory mem 内存 message msg 消息 middle mid 中值 multiplication mul 乘法 number num 数量、编号 operand opnd 操作数 operator optr 操作 optimization opt 最优 packet pkt 消息包 pointer ptr 指针 positon pos 位置 previous pre / prev 以前的 receive recv 收到、接收 record rcd 记录 result res 结果 return ret 返回 source src 源头 stack stk 栈 string str 字符串 subtraction sub 减 table tab 表 temporary tmp / temp 临时 timestamp ts 时间戳 total tot 全部的 value val 值"},{"title":"斯坦福大学2014(吴恩达)机器学习教程中文笔记","date":"2019-10-07T01:20:01.000Z","path":"posts/441574646/","text":"1. 引言(Introduction) 1.1. 欢迎 1.2. 机器学习是什么？ 1.3. 监督学习 1.4. 无监督学习 2. 单变量线性回归**(Linear Regression with One Variable**) 2.1. 模型表示 2.2. 代价函数 2.3. 代价函数的直观理解I 2.4. 代价函数的直观理解II 2.5. 梯度下降 2.6. 梯度下降的直观理解 2.7. 梯度下降的线性回归 2.8. 接下来的内容 3. 线性代数回顾(Linear Algebra Review) 3.1. 矩阵和向量 3.2. 加法和标量乘法 3.3. 矩阵向量乘法 3.4. 矩阵乘法 3.5. 矩阵乘法的性质 3.6. 逆、转置 4. 多变量线性回归(Linear Regression with Multiple Variables) 4.1. 多维特征 4.2. 多变量梯度下降 4.3. 梯度下降法实践1-特征缩放 4.4. 梯度下降法实践2-学习率 4.5. 特征和多项式回归 4.6. 正规方程 4.7. 正规方程及不可逆性（选修） 5. Octave教程(Octave Tutorial) 5.1. 基本操作 5.2. 移动数据 5.3. 计算数据 5.4. 绘图数据 5.5. 控制语句：for，while，if语句 5.6. 向量化 88 5.7. 工作和提交的编程练习 6. 逻辑回归(Logistic Regression) 6.1. 分类问题 6.2. 假说表示 6.3. 判定边界 6.4. 代价函数 6.5. 简化的成本函数和梯度下降 6.6. 高级优化 6.7. 多类别分类：一对多 7. 正则化(Regularization) 7.1. 过拟合的问题 7.2. 代价函数 7.3. 正则化线性回归 7.4. 正则化的逻辑回归模型 8. 神经网络：表述(Neural Networks: Representation) 8.1. 非线性假设 8.2. 神经元和大脑 8.3. 模型表示1 8.4. 模型表示2 8.5. 样本和直观理解1 8.6. 样本和直观理解II 8.7. 多类分类 9. 神经网络的学习(Neural Networks: Learning) 9.1. 代价函数 9.2. 反向传播算法 9.3. 反向传播算法的直观理解 9.4. 实现注意：展开参数 9.5. 梯度检验 9.6. 随机初始化 9.7. 综合起来 9.8. 自主驾驶 10. 应用机器学习的建议(Advice for Applying Machine Learning) 10.1. 决定下一步做什么 10.2. 评估一个假设 10.3. 模型选择和交叉验证集 10.4. 诊断偏差和方差 10.5. 正则化和偏差/方差 10.6. 学习曲线 10.7. 决定下一步做什么 11. 机器学习系统的设计(Machine Learning System Design) 11.1. 首先要做什么 11.2. 误差分析 11.3. 类偏斜的误差度量 11.4. 查准率和查全率之间的权衡 11.5. 机器学习的数据 12. 支持向量机(Support Vector Machines) 12.1. 优化目标 12.2. 大边界的直观理解 12.3. 大边界分类背后的数学（选修） 12.4. 核函数1 12.5. 核函数2 12.6. 使用支持向量机 13. 聚类(Clustering) 13.1. 无监督学习：简介 13.2. K-均值算法 13.3. 优化目标 13.4. 随机初始化 13.5. 选择聚类数 14. 降维(Dimensionality Reduction) 14.1. 动机一：数据压缩 14.2. 动机二：数据可视化 14.3. 主成分分析问题 14.4. 主成分分析算法 14.5. 选择主成分的数量 14.6. 重建的压缩表示 14.7. 主成分分析法的应用建议 15. 异常检测(Anomaly Detection) 15.1. 问题的动机 15.2. 高斯分布 15.3. 算法 15.4. 开发和评价一个异常检测系统 15.5. 异常检测与监督学习对比 15.6. 选择特征 15.7. 多元高斯分布（选修） 15.8. 使用多元高斯分布进行异常检测（选修） 16. 推荐系统(Recommender Systems) 16.1. 问题形式化 16.2. 基于内容的推荐系统 16.3. 协同过滤 16.4. 协同过滤算法 16.5. 向量化：低秩矩阵分解 16.6. 推行工作上的细节：均值归一化 17. 大规模机器学习(Large Scale Machine Learning) 17.1. 大型数据集的学习 17.2. 随机梯度下降法 17.3. 小批量梯度下降 17.4. 随机梯度下降收敛 17.5. 在线学习 17.6. 映射化简和数据并行 18. 应用实例：图片文字识别(Application Example: Photo OCR) 18.1. 问题描述和流程图 18.2. 滑动窗口 18.3. 获取大量数据和人工数据 18.4. 上限分析：哪部分管道的接下去做 19. 总结(Conclusion) 19.1. 总结和致谢 1. 引言(Introduction) 1.1. 欢迎 1.2. 机器学习是什么？ 1.3. 监督学习 1.4. 无监督学习 2. 单变量线性回归**(Linear Regression with One Variable**) 2.1. 模型表示 2.2. 代价函数 2.3. 代价函数的直观理解I 2.4. 代价函数的直观理解II 2.5. 梯度下降 2.6. 梯度下降的直观理解 2.7. 梯度下降的线性回归 2.8. 接下来的内容 3. 线性代数回顾(Linear Algebra Review) 3.1. 矩阵和向量 3.2. 加法和标量乘法 3.3. 矩阵向量乘法 3.4. 矩阵乘法 3.5. 矩阵乘法的性质 3.6. 逆、转置 4. 多变量线性回归(Linear Regression with Multiple Variables) 4.1. 多维特征 4.2. 多变量梯度下降 4.3. 梯度下降法实践1-特征缩放 4.4. 梯度下降法实践2-学习率 4.5. 特征和多项式回归 4.6. 正规方程 4.7. 正规方程及不可逆性（选修） 5. Octave教程(Octave Tutorial) 5.1. 基本操作 5.2. 移动数据 5.3. 计算数据 5.4. 绘图数据 5.5. 控制语句：for，while，if语句 5.6. 向量化 88 5.7. 工作和提交的编程练习 6. 逻辑回归(Logistic Regression) 6.1. 分类问题 6.2. 假说表示 6.3. 判定边界 6.4. 代价函数 6.5. 简化的成本函数和梯度下降 6.6. 高级优化 6.7. 多类别分类：一对多 7. 正则化(Regularization) 7.1. 过拟合的问题 7.2. 代价函数 7.3. 正则化线性回归 7.4. 正则化的逻辑回归模型 8. 神经网络：表述(Neural Networks: Representation) 8.1. 非线性假设 8.2. 神经元和大脑 8.3. 模型表示1 8.4. 模型表示2 8.5. 样本和直观理解1 8.6. 样本和直观理解II 8.7. 多类分类 9. 神经网络的学习(Neural Networks: Learning) 9.1. 代价函数 9.2. 反向传播算法 9.3. 反向传播算法的直观理解 9.4. 实现注意：展开参数 9.5. 梯度检验 9.6. 随机初始化 9.7. 综合起来 9.8. 自主驾驶 10. 应用机器学习的建议(Advice for Applying Machine Learning) 10.1. 决定下一步做什么 10.2. 评估一个假设 10.3. 模型选择和交叉验证集 10.4. 诊断偏差和方差 10.5. 正则化和偏差/方差 10.6. 学习曲线 10.7. 决定下一步做什么 11. 机器学习系统的设计(Machine Learning System Design) 11.1. 首先要做什么 11.2. 误差分析 11.3. 类偏斜的误差度量 11.4. 查准率和查全率之间的权衡 11.5. 机器学习的数据 12. 支持向量机(Support Vector Machines) 12.1. 优化目标 12.2. 大边界的直观理解 12.3. 大边界分类背后的数学（选修） 12.4. 核函数1 12.5. 核函数2 12.6. 使用支持向量机 13. 聚类(Clustering) 13.1. 无监督学习：简介 13.2. K-均值算法 13.3. 优化目标 13.4. 随机初始化 13.5. 选择聚类数 14. 降维(Dimensionality Reduction) 14.1. 动机一：数据压缩 14.2. 动机二：数据可视化 14.3. 主成分分析问题 14.4. 主成分分析算法 14.5. 选择主成分的数量 14.6. 重建的压缩表示 14.7. 主成分分析法的应用建议 15. 异常检测(Anomaly Detection) 15.1. 问题的动机 15.2. 高斯分布 15.3. 算法 15.4. 开发和评价一个异常检测系统 15.5. 异常检测与监督学习对比 15.6. 选择特征 15.7. 多元高斯分布（选修） 15.8. 使用多元高斯分布进行异常检测（选修） 16. 推荐系统(Recommender Systems) 16.1. 问题形式化 16.2. 基于内容的推荐系统 16.3. 协同过滤 16.4. 协同过滤算法 16.5. 向量化：低秩矩阵分解 16.6. 推行工作上的细节：均值归一化 17. 大规模机器学习(Large Scale Machine Learning) 17.1. 大型数据集的学习 17.2. 随机梯度下降法 17.3. 小批量梯度下降 17.4. 随机梯度下降收敛 17.5. 在线学习 17.6. 映射化简和数据并行 18. 应用实例：图片文字识别(Application Example: Photo OCR) 18.1. 问题描述和流程图 18.2. 滑动窗口 18.3. 获取大量数据和人工数据 18.4. 上限分析：哪部分管道的接下去做 19. 总结(Conclusion) 19.1. 总结和致谢"},{"title":"Flutter基础教程","date":"2019-10-05T17:07:25.000Z","path":"posts/777259726/","text":""},{"title":"Visual Studio Code配置","date":"2019-10-05T13:21:59.000Z","path":"posts/1940182388/","text":"推荐插件 推荐插件 插件列表 插件 安装量 描述 SQLite 测试 alanwalk.markdown-toc 测试 alefragnani.bookmarks 测试 一键安装脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!env python# -*- Coding: utf-8 -*-from os import getcwd, altsepfrom subprocess import Popen, PIPE, STDOUT, TimeoutExpiredfrom func_timeout import func_timeout, FunctionTimedOutdef main(): tupleExtension = ( 'alanwalk.markdown-toc', 'alefragnani.bookmarks', 'alexcvzz.vscode-sqlite', 'anseki.vscode-color', 'austin.code-gnu-global', 'bierner.markdown-preview-github-styles', 'christian-kohler.npm-intellisense', 'coenraads.bracket-pair-colorizer', 'dan-c-underwood.arm', 'dart-code.dart-code', 'dart-code.flutter', 'davidanson.vscode-markdownlint', 'donjayamanne.githistory', 'dotjoshjohnson.xml', 'eamodio.gitlens', 'eg2.vscode-npm-script', 'equinusocio.vsc-material-theme', 'esbenp.prettier-vscode', 'gruntfuggly.todo-tree', 'hookyqr.beautify', 'jerryhong.autofilename', 'jock.svg', 'k--kato.intellij-idea-keybindings', 'mathiasfrohlich.kotlin', 'michalyao.evermonkey', 'ms-mssql.mssql', 'ms-python.python', 'ms-vscode-remote.remote-ssh', 'ms-vscode-remote.remote-ssh-edit', 'ms-vscode-remote.remote-ssh-explorer', 'ms-vscode-remote.remote-wsl', 'ms-vscode.cpptools', 'ms-vscode.powershell', 'naumovs.color-highlight', 'oderwat.indent-rainbow', 'pkief.material-icon-theme', 'rsbondi.highlight-words', 'ryannaddy.vscode-format', 'shan.code-settings-sync', 'slevesque.vscode-hexdump', 'tabnine.tabnine-vscode', 'tushortz.python-extended-snippets', 'yzhang.markdown-all-in-one', 'zhoufeng.pyqt-integration', ) curdir = getcwd() index = 1 total = len(tupleExtension) for extension in tupleExtension: while True: print(\"[\" + str(index) + \"/\" + str(total) + \"] \" + curdir + altsep + \"bin\" + altsep + \"code --install-extension \" + extension + \" --force\") proc = Popen(curdir + altsep + \"bin\" + altsep + \"code --install-extension \" + extension + \" --force\", shell=True, stdout=PIPE, stderr=STDOUT, encoding=\"utf8\") try: outs, errs = proc.communicate(timeout=60) except TimeoutExpired: proc.kill() if not None == outs: print(outs) if ('was successfully installed' in outs) or ('is already installed' in outs): index += 1 breakif __name__ == \"__main__\": main()"},{"title":"开源项目推荐","date":"2019-10-05T13:21:59.000Z","path":"posts/1940182387/","text":"1. Flutter 1.1. 电子书《Flutter实战》 Python Python - 100天从新手到大师 机器学习 机器学习100天 Tools Flight rules for Git 1. Flutter 1.1. 电子书《Flutter实战》 电子书web版本：《Flutter实战》 电子书开源项目：flutter-in-action Python Python - 100天从新手到大师 Python-100-Days，一个从入门到精通百日教程，包含Python基础/进阶教程，爬虫、Django、机器学习等 机器学习 机器学习100天 机器学习100天，一个非常详尽的100天学习机器学习的项目 Tools Flight rules for Git Flight rules for Git，项目里面罗列了git在实用的过程中出现的常见问题时的标准处理方案，对于git操作不熟悉的用户来说是非常有用的。"},{"title":"zsh详解","date":"2019-09-16T06:14:04.000Z","path":"posts/1879721729/","text":"1. zsh快捷键 2. oh-my-zsh框架配置 3. zsh主题配置 1. zsh快捷键 快捷键 功能 ⌃ + u 清空当前行 ⌃ + a 移动到行首 ⌃ + e 移动到行尾 ⌃ + f 向前移动 ⌃ + b 向后移动 ⌃ + p 上一条命令 ⌃ + n 下一条命令 ⌃ + r 搜索历史命令 ⌃ + y 召回最近用命令删除的文字 ⌃ + h 删除光标之前的字符 ⌃ + d 删除光标所指的字符 ⌃ + w 删除光标之前的单词 ⌃ + k 删除从光标到行尾的内容 ⌃ + t 交换光标和之前的字符 ⌘ + Click 可以打开文件，文件夹和链接 ⌘ + n 新建窗口 ⌘ + t 新建标签页 ⌘ + w 关闭当前页 ⌘ + 数字&amp;⌘ + 方向键 切换标签页 ⌥⌘ + 数字 切换窗口 ⌘ + enter 切换全屏 ⌘ + d 左右分屏 ⇧⌘ + d 上下分屏 ⌘ + ; 自动补全历史记录 ⇧⌘ + h 自动补全剪贴板历史 ⌥⌘ + e 查找所有来定位某个标签页 ⌘ + r&amp;⌃ + l 清屏 ⌘ + / 显示光标位置 ⌥⌘ + b 历史回放 ⌘ + f 查找，然后用tab和⇧ + tab可以向右和向左补全，补全之后的内容会被自动复制， 还可以用⌥ + enter将查找结果输入终端 2. oh-my-zsh框架配置 详情请参考zsh配置 123456789101112131415161718192021222324252627# Uncomment the following line to display red dots whilst waiting for completion.COMPLETION_WAITING_DOTS=\"true\"# Which plugins would you like to load?# Standard plugins can be found in ~/.oh-my-zsh/plugins/*# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=( git colored-man-pages colorize command-not-found cp compleat sudo # git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting zsh-syntax-highlighting # git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions zsh-autosuggestions)# zsh-autosuggestionsZSH_AUTOSUGGEST_STRATEGY=(history completion)# User configurationexport TERM=xterm-256color 3. zsh主题配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101diff --git a/.zshrc b/.zshrcindex 9553c66..1f90533 100644--- a/.zshrc+++ b/.zshrc@@ -9,7 +9,6 @@ export ZSH=\"/home/Cyril/.oh-my-zsh\" # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/robbyrussell/oh-my-zsh/wiki/Themes-ZSH_THEME=\"robbyrussell\"+# ZSH_THEME=\"robbyrussell\"+ZSH_THEME=\"powerlevel10k/powerlevel10k\" # Set list of themes to pick from when loading at random # Setting this variable when ZSH_THEME=random will cause zsh to loaddiff --git a/.p10k.zsh b/.p10k.zshindex 9fb0e29..9d1d905 100644--- a/.p10k.zsh+++ b/.p10k.zsh@@ -38,6 +38,7 @@ vcs # git status # =========================[ Line #2 ]========================= newline+ context prompt_char # prompt symbol )@@ -65,18 +66,19 @@ kubecontext # current kubernetes context (https://kubernetes.io/) terraform # terraform workspace (https://www.terraform.io) aws # aws profile (https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html)- context # user@hostname+ # context # user@hostname nordvpn # nordvpn connection status, linux only (https://nordvpn.com/) ranger # ranger shell (https://github.com/ranger/ranger) # vpn_ip # virtual private network indicator # ram # free RAM # load # CPU load- time # current time+ # time # current time # =========================[ Line #2 ]========================= newline # public_ip # public IP address # proxy # system-wide http/https/ftp proxy # battery # internal battery+ time # current time # example # example user-defined segment (see prompt_example function below) )@@ -301,6 +303,9 @@ # Branch icon. Set this parameter to '\\uF126 ' for the popular Powerline branch icon. typeset -g POWERLEVEL9K_VCS_BRANCH_ICON='\\uF126 ' POWERLEVEL9K_VCS_BRANCH_ICON=$&#123;(g::)POWERLEVEL9K_VCS_BRANCH_ICON&#125;+ typeset -g POWERLEVEL9K_VCS_COMMIT_ICON=''+ # typeset -g POWERLEVEL9K_VCS_REMOTE_BRANCH_ICON=''+ typeset -g POWERLEVEL9K_VCS_TAG_ICON='' # Untracked files icon. It's really a question mark, your font isn't broken. # Change the value of this parameter to show a different icon.@@ -349,10 +354,10 @@ res+=\"$&#123;clean&#125;$&#123;POWERLEVEL9K_VCS_BRANCH_ICON&#125;\" where=$&#123;(V)VCS_STATUS_LOCAL_BRANCH&#125; elif [[ -n $VCS_STATUS_TAG ]]; then- res+=\"$&#123;meta&#125;#\"+ res+=\"$&#123;meta&#125;$&#123;(g::)POWERLEVEL9K_VCS_TAG_ICON&#125;\" where=$&#123;(V)VCS_STATUS_TAG&#125; else- res+=\"$&#123;meta&#125;@\"+ res+=\"$&#123;meta&#125;$&#123;(g::)POWERLEVEL9K_VCS_COMMIT_ICON&#125;\" where=$&#123;VCS_STATUS_COMMIT[1,8]&#125; fi@@ -362,8 +367,8 @@ res+=\"$&#123;clean&#125;$&#123;where//\\%/%%&#125;\" # escape % # Show tracking branch name if it differs from local branch.- if [[ -n $&#123;VCS_STATUS_REMOTE_BRANCH:#$VCS_STATUS_LOCAL_BRANCH&#125; ]]; then- res+=\"$&#123;meta&#125;:$&#123;clean&#125;$&#123;(V)VCS_STATUS_REMOTE_BRANCH//\\%/%%&#125;\" # escape %+ if [[ -n $&#123;VCS_STATUS_REMOTE_BRANCH&#125; ]]; then+ res+=\"$&#123;meta&#125;--&gt;$&#123;(g::)POWERLEVEL9K_VCS_REMOTE_BRANCH_ICON&#125;$&#123;clean&#125;$&#123;(V)VCS_STATUS_REMOTE_BRANCH//\\%/%%&#125;\" # escape % fi # ⇣42 if behind the remote.@@ -436,15 +441,15 @@ # Status when it's just an error code (e.g., '1'). No need to show it if prompt_char is enabled as # it will signify error by turning red.- typeset -g POWERLEVEL9K_STATUS_ERROR=false+ typeset -g POWERLEVEL9K_STATUS_ERROR=true typeset -g POWERLEVEL9K_STATUS_ERROR_FOREGROUND=160- typeset -g POWERLEVEL9K_STATUS_ERROR_VISUAL_IDENTIFIER_EXPANSION='↵'+ typeset -g POWERLEVEL9K_STATUS_ERROR_VISUAL_IDENTIFIER_EXPANSION='✘' # Status when the last command was terminated by a signal. typeset -g POWERLEVEL9K_STATUS_ERROR_SIGNAL=true typeset -g POWERLEVEL9K_STATUS_ERROR_SIGNAL_FOREGROUND=160 # Use terse signal names: \"INT\" instead of \"SIGINT(2)\".- typeset -g POWERLEVEL9K_STATUS_VERBOSE_SIGNAME=false+ typeset -g POWERLEVEL9K_STATUS_VERBOSE_SIGNAME=true typeset -g POWERLEVEL9K_STATUS_ERROR_SIGNAL_VISUAL_IDENTIFIER_EXPANSION='↵' # Status when some part of a pipe command fails and the overall exit status is also non-zero."},{"title":"Kotlin编程详解","date":"2019-09-15T11:05:12.000Z","path":"posts/787202829/","text":""},{"title":"C/C++编程技巧集锦","date":"2019-09-14T15:45:28.000Z","path":"posts/2902948804/","text":"1. H1 2. H2 1. H1 2. H2"},{"title":"Linux驱动开发","date":"2019-09-13T15:30:50.000Z","path":"posts/3590725912/","text":"1. 设备树 1.1. 设备树基础 1.2. 设备树语法 1.3. 设备树匹配解析规则 1.4. 支持设备树的驱动开发 1.5. Linux中常用的设备树API 1. 设备树 1.1. 设备树基础 1.2. 设备树语法 12345678910111213141516171819202122232425262728/dts-v1/;#include &lt;dt-bindings/input/input.h&gt;#include \"armv7-m.dtsi\"/ &#123; model = compatible = chosen &#123; bootargs = \"console=ttySAC2,115200n8 root=/dev/nfs nfsroot=192.168.0.101:/home/run/work/rootfs/rootfs_3.16.57 ip=192.1 68.0.20 init=/linuxrci earlyprintk\"; &#125;; aliases &#123; &#125; node@0 &#123; an-empty-property; a-string-property = \"A string\"; a-string-list-property = \"first string\", \"second string\"; a-byte-data-property = [0x01 0x23 0x45 0x67]; child-node@0 &#123; &#125; &#125;&#125; 1.3. 设备树匹配解析规则 1.4. 支持设备树的驱动开发 1.5. Linux中常用的设备树API 参考资料： [1] 设备树专题"}]